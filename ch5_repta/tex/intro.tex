\section{Introduction}

% *** Background of energy harvesting and intermittent systems ***

Energy harvesting has become a promising power solution for the Internet of Things, liberating wireless sensors from batteries and the power grid. 
Batteryless devices harvest ambient energy, such as light, radio-frequency, and mechanical movement, which is then buffered in a capacitor. 
As the harvested power is typically insufficient for continuous operation, such devices operate in an intermittent way -- when a certain amount of energy is collected, the processor wakes up, executes program until the amount of energy falls below a threshold, where it sleeps or dies, and waits for the next energy cycle [ref]. 
Prior work in \textit{intermittent systems} has developed sophisticated methods to preserve forward progress across frequent power interruptions by carefully \textit{checkpointing} the volatile computing state in CPU registers and volatile memory into non-volatile memory (NVM), and restoring it on reboot [ref]. 


% *** Previous work on intermittent peripheral operations ***

Apart from computing, embedded sensor systems need to utilize peripherals, such as sensors, computational accelerators, and radios, which typically require \textit{atomicity}.
In the context of intermittent systems, an atomic operation should not be checkpointed during execution; if interrupted by power failures, it should restart rather than checkpoint and resume.
A peripheral operation is considered atomic because it is infeasible to completely read, save, and restore the intermediate internal state of peripherals, and even if possible, could produce unwanted results. 
% Need elaboration
(Example)
% disable checkpoints during execution
Prior works on intermittent peripheral operations either individually dedicate an  design-time calibrated energy budget for each peripheral operation~\cite{gomez2016dynamic}, or allocate a universal energy budget that ensure the most energy hungry operation can finish in one energy cycle~\cite{maeng2019supporting}.



% *** Offline profiling and fixed threshold is impractical due to variability ***

However, in this paper we propose that manually profiling each peripheral operation and setting fixed thresholds is impractical due to variability in capacitance and energy consumption, where we have considered the following cases: 

\begin{enumerate}
    \item \textit{Variability in capacitance:} 
    As a component for buffering energy in intermittent systems, capacitors typically present a $\pm$10-20\% tolerance on rated capacitance. 
    Capacitors also age over time. 
    It is shown that capacitance can decrease by 7.2\% in 3000 hours under a \SI{25}{\celsius} ambient temperature in experiments~\cite{kulkarni2010experimental}, and by 50\% within 10 years under \SI{40}{\celsius} as manufacturers stated~\cite{vishaycapacitor}.
    A degraded capacitor does not change the load consumption, but can increase the voltage difference before and after an operation, and hence makes the pre-defined voltage threshold unsafe. 

    \item \textit{Variable amount of data to process:}
    A peripheral function can accept a runtime variable amount of data, e.g. sending different lengths of packets or encrypting different amount of data. 
    Statistically, this linearly scales the charge consumption.

    \item \textit{Variability in peripheral configurations:}
    A peripheral can run with variable configurations at runtime, and demonstrate variable performance and energy consumption. 
    For example, an AES accelerator can encrypt or decrypt data with 128-, 192-, or 256-bit keys. 
    A longer key provides more security, but also takes more time and energy to complete.
    % Can refer to "A control flow" for the need of runtime configurations

    \item \textit{Device variability:}
    Devices have their variation in power consumption, even with the same part number. 
    A threshold profiled on one device can be inadequate on another. 
\end{enumerate}

A fixed threshold can be violated if any of the above cases happen, and lead to non-termination. 
In practical deployment, profiling every atomic operation for every device with all runtime scenarios could an extremely tedious work.
Considering this complexity, it is unrealistic to profile the energy budget in every scenario and customize a voltage threshold accordingly. 



% *** An optimized threshold improves efficiency ***

On the other hand, using only one high voltage threshold, though probably avoids non-termination, can affect system efficiency. Microcontrollers and peripheral devices typically draw more current at a higher supply voltage. The high voltage in the buffering capacitor can also decrease the charging efficiency of energy harvesters and increase system leakage. Hence, setting a high voltage threshold for the processor to wake up results in a superlinear long charging time, which therefore slows down the system execution or even leave the system in a infinite wait at low input power. 


% *** What we do to address it ***

To address the above issue, we propose \nn{} (online profiling and threshold adaptation), a methodology that profiles energy consumption of operations at runtime and allocate adaptive thresholds based on newly profiled consumption and user-defined parameters. 
\nn{} profiles the voltage decrease that an operation can cause without any energy input during the operation, while the energy harvesting supply is connected. 
The profiling strategy is to measure the input current in the charging cycle so as to calculate the maximum drop of supply voltage in the discharging cycle. 
The profiled energy budget can therefore guarantee the completion of an atomic operation. 
Based on the profiling results, \nn{} dynamically adapts the threshold for each atomic operation, with an option of scaling threshold by user-defined parameters or peripheral configurations.



*** Contributions and paper structure ***


